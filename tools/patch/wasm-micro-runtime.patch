diff --git a/core/app-framework/app_framework.cmake b/core/app-framework/app_framework.cmake
index 8ad43de..b8a63d8 100644
--- a/core/app-framework/app_framework.cmake
+++ b/core/app-framework/app_framework.cmake
@@ -33,6 +33,10 @@ function (add_module_native arg)
         ${APP_FRAMEWORK_ROOT_DIR}/${ARGV0}/native/*.h
         ${APP_FRAMEWORK_ROOT_DIR}/${ARGV0}/native/*.inl
     )
+
+    LIST (APPEND WASM_APP_LIBS_DIR ${APP_FRAMEWORK_ROOT_DIR}/${ARGV0}/native)
+    set (WASM_APP_LIBS_DIR ${WASM_APP_LIBS_DIR} PARENT_SCOPE)
+
     LIST (APPEND RUNTIME_LIB_HEADER_LIST ${header})
     set (RUNTIME_LIB_HEADER_LIST ${RUNTIME_LIB_HEADER_LIST} PARENT_SCOPE)
 
diff --git a/core/app-mgr/app-manager/module_wasm_app.c b/core/app-mgr/app-manager/module_wasm_app.c
index 7b826d6..b4e4df3 100644
--- a/core/app-mgr/app-manager/module_wasm_app.c
+++ b/core/app-mgr/app-manager/module_wasm_app.c
@@ -431,6 +431,7 @@ wasm_app_prepare_wasi_dir(wasm_module_t module, const char *module_name,
 static void *
 wasm_app_routine(void *arg)
 {
+    wasm_function_inst_t func_start = NULL;
     wasm_function_inst_t func_onInit;
     wasm_function_inst_t func_onDestroy;
 
@@ -445,7 +446,6 @@ wasm_app_routine(void *arg)
 
 #if WASM_ENABLE_LIBC_WASI != 0
     if (wasm_runtime_is_wasi_mode(inst)) {
-        wasm_function_inst_t func_start;
         /* In wasi mode, we should call function named "_start"
            which initializes the wasi envrionment. The "_start" function
            will call "main" function */
@@ -466,22 +466,24 @@ wasm_app_routine(void *arg)
     }
 #endif
 
-    /* Call app's onInit() method */
-    func_onInit = app_manager_lookup_function(inst, "_on_init", "()");
-    if (!func_onInit) {
-        app_manager_printf("Cannot find function on_init().\n");
-        goto fail1;
-    }
+    if (!func_start) {
+        /* Call app's onInit() method */
+        func_onInit = app_manager_lookup_function(inst, "_on_init", "()");
+        if (!func_onInit) {
+            app_manager_printf("Cannot find function on_init().\n");
+            goto fail1;
+        }
 
-    if (!wasm_runtime_call_wasm(wasm_app_data->exec_env, func_onInit, 0,
-                                NULL)) {
-        const char *exception = wasm_runtime_get_exception(inst);
-        bh_assert(exception);
-        app_manager_printf("Got exception running WASM code: %s\n", exception);
-        wasm_runtime_clear_exception(inst);
-        /* call on_destroy() in case some resources are opened in on_init()
-         * and then exception thrown */
-        goto fail2;
+        if (!wasm_runtime_call_wasm(wasm_app_data->exec_env, func_onInit, 0,
+                                    NULL)) {
+            const char *exception = wasm_runtime_get_exception(inst);
+            bh_assert(exception);
+            app_manager_printf("Got exception running WASM code: %s\n", exception);
+            wasm_runtime_clear_exception(inst);
+            /* call on_destroy() in case some resources are opened in on_init()
+            * and then exception thrown */
+            goto fail2;
+        }
     }
 
     /* Enter queue loop run to receive and process applet queue message */
@@ -1667,9 +1669,9 @@ destroy_all_aot_sections(aot_section_list_t sections)
     while (cur) {
         aot_section_t *next = cur->next;
         if (cur->section_body != NULL) {
-            if (cur->section_type == AOT_SECTION_TYPE_TEXT)
-                os_munmap(cur->section_body, cur->section_body_size);
-            else
+            if (cur->section_type == AOT_SECTION_TYPE_TEXT) {
+                // os_munmap(cur->section_body, cur->section_body_size);
+            } else
                 APP_MGR_FREE(cur->section_body);
         }
         APP_MGR_FREE(cur);
diff --git a/core/iwasm/aot/aot_loader.c b/core/iwasm/aot/aot_loader.c
index d6560cc..3ecf12b 100644
--- a/core/iwasm/aot/aot_loader.c
+++ b/core/iwasm/aot/aot_loader.c
@@ -1579,7 +1579,7 @@ load_function_section(const uint8 *buf, const uint8 *buf_end, AOTModule *module,
                           "invalid function code offset");
             return false;
         }
-        module->func_ptrs[i] = (uint8 *)module->code + text_offset;
+        module->func_ptrs[i] = (uint8 *)module->code + text_offset + (SOC_IROM_LOW - SOC_DROM_LOW);
 #if defined(BUILD_TARGET_THUMB) || defined(BUILD_TARGET_THUMB_VFP)
         /* bits[0] of thumb function address must be 1 */
         module->func_ptrs[i] = (void *)((uintptr_t)module->func_ptrs[i] | 1);
diff --git a/core/iwasm/aot/arch/aot_reloc_xtensa.c b/core/iwasm/aot/arch/aot_reloc_xtensa.c
index b5b262a..86a7648 100644
--- a/core/iwasm/aot/arch/aot_reloc_xtensa.c
+++ b/core/iwasm/aot/arch/aot_reloc_xtensa.c
@@ -8,6 +8,10 @@
 #define R_XTENSA_32 1        /* Direct 32 bit */
 #define R_XTENSA_SLOT0_OP 20 /* PC relative */
 
+#define IN_SPACE(addr, start, size) \
+    (((uintptr_t)(addr) >= (uintptr_t)(start)) && \
+     ((uintptr_t)(addr) <  ((uintptr_t)(start) + (uintptr_t)(size))))
+
 /* clang-format off */
 /* for soft-float */
 void __floatsidf();
@@ -214,8 +218,15 @@ apply_relocation(AOTModule *module, uint8 *target_section_addr,
             }
             CHECK_RELOC_OFFSET(4);
             initial_addend = *(int32 *)insn_addr;
-            *(uintptr_t *)insn_addr = (uintptr_t)symbol_addr + initial_addend
+
+            uintptr_t target_addr = (uintptr_t)symbol_addr + initial_addend
                                       + (intptr_t)reloc_addend;
+
+            if (IN_SPACE(target_addr, module->code, module->code_size)) {
+                target_addr += (SOC_IROM_LOW - SOC_DROM_LOW);
+            }
+
+            *(uintptr_t *)insn_addr = target_addr;
             break;
         }
 
diff --git a/core/iwasm/libraries/lib-socket/inc/wasi_socket_ext.h b/core/iwasm/libraries/lib-socket/inc/wasi_socket_ext.h
index 15ec0f5..ee029c4 100644
--- a/core/iwasm/libraries/lib-socket/inc/wasi_socket_ext.h
+++ b/core/iwasm/libraries/lib-socket/inc/wasi_socket_ext.h
@@ -95,15 +95,15 @@ socket(int domain, int type, int protocol);
  * Note: This is similar to `accept`
  */
 int32_t
-__imported_wasi_snapshot_preview1_sock_accept(int32_t arg0, int32_t arg1)
+__imported_wasi_snapshot_preview1_sock_accept(int32_t arg0, int32_t arg1, int32_t arg2)
     __attribute__((__import_module__("wasi_snapshot_preview1"),
                    __import_name__("sock_accept")));
 
 static inline __wasi_errno_t
-__wasi_sock_accept(__wasi_fd_t fd, __wasi_fd_t *fd_new)
+__wasi_sock_accept(__wasi_fd_t fd, __wasi_fdflags_t flags, __wasi_fd_t *fd_new)
 {
     return (__wasi_errno_t)__imported_wasi_snapshot_preview1_sock_accept(
-        (int32_t)fd, (int32_t)fd_new);
+        (int32_t)fd, flags, (int32_t)fd_new);
 }
 
 /**
diff --git a/core/iwasm/libraries/lib-socket/src/wasi/wasi_socket_ext.c b/core/iwasm/libraries/lib-socket/src/wasi/wasi_socket_ext.c
index a96156f..2983be3 100644
--- a/core/iwasm/libraries/lib-socket/src/wasi/wasi_socket_ext.c
+++ b/core/iwasm/libraries/lib-socket/src/wasi/wasi_socket_ext.c
@@ -96,7 +96,7 @@ accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen)
     __wasi_fd_t new_sockfd;
     __wasi_errno_t error;
 
-    error = __wasi_sock_accept(sockfd, &new_sockfd);
+    error = __wasi_sock_accept(sockfd, 0, &new_sockfd);
     HANDLE_ERROR(error)
 
     // error = sock_addr_remote(new_sockfd, addr, addrlen);
diff --git a/core/iwasm/libraries/libc-wasi/libc_wasi_wrapper.c b/core/iwasm/libraries/libc-wasi/libc_wasi_wrapper.c
index 7611999..44ffe61 100644
--- a/core/iwasm/libraries/libc-wasi/libc_wasi_wrapper.c
+++ b/core/iwasm/libraries/libc-wasi/libc_wasi_wrapper.c
@@ -994,7 +994,7 @@ wasi_random_get(wasm_exec_env_t exec_env, void *buf, uint32 buf_len)
 }
 
 static wasi_errno_t
-wasi_sock_accept(wasm_exec_env_t exec_env, wasi_fd_t fd, wasi_fd_t *fd_new)
+wasi_sock_accept(wasm_exec_env_t exec_env, wasi_fd_t fd, wasi_fdflags_t flags, wasi_fd_t *fd_new)
 {
     wasm_module_inst_t module_inst = get_module_inst(exec_env);
     wasi_ctx_t wasi_ctx = get_wasi_ctx(module_inst);
@@ -1044,7 +1044,16 @@ static wasi_errno_t
 wasi_sock_addr_resolve(wasm_exec_env_t exec_env, wasi_fd_t fd, const char *host,
                        wasi_ip_port_t port, uint8 *buf, wasi_size_t size)
 {
-    return __WASI_ENOSYS;
+    wasm_module_inst_t module_inst = get_module_inst(exec_env);
+    wasi_ctx_t wasi_ctx = get_wasi_ctx(module_inst);
+    struct fd_table *curfds = NULL;
+
+    if (!wasi_ctx)
+        return __WASI_EACCES;
+
+    curfds = wasi_ctx_get_curfds(module_inst, wasi_ctx);
+
+    return wasi_ssp_sock_addr_resolve(curfds, fd, host, port, buf, size);
 }
 
 static wasi_errno_t
@@ -1091,26 +1100,62 @@ static wasi_errno_t
 wasi_sock_get_recv_buf_size(wasm_exec_env_t exec_env, wasi_fd_t fd,
                             wasi_size_t *size)
 {
-    return __WASI_ENOSYS;
+    wasm_module_inst_t module_inst = get_module_inst(exec_env);
+    wasi_ctx_t wasi_ctx = get_wasi_ctx(module_inst);
+    struct fd_table *curfds = NULL;
+
+    if (!wasi_ctx)
+        return __WASI_EACCES;
+
+    curfds = wasi_ctx_get_curfds(module_inst, wasi_ctx);
+
+    return wasi_ssp_sock_get_recv_buf_size(curfds, fd, size);
 }
 
 static wasi_errno_t
 wasi_sock_get_reuse_addr(wasm_exec_env_t exec_env, wasi_fd_t fd, uint8 *reuse)
 {
-    return __WASI_ENOSYS;
+    wasm_module_inst_t module_inst = get_module_inst(exec_env);
+    wasi_ctx_t wasi_ctx = get_wasi_ctx(module_inst);
+    struct fd_table *curfds = NULL;
+
+    if (!wasi_ctx)
+        return __WASI_EACCES;
+
+    curfds = wasi_ctx_get_curfds(module_inst, wasi_ctx);
+
+    return wasi_ssp_sock_get_reuse_addr(curfds, fd, reuse);
 }
 
 static wasi_errno_t
 wasi_sock_get_reuse_port(wasm_exec_env_t exec_env, wasi_fd_t fd, uint8 *reuse)
 {
-    return __WASI_ENOSYS;
+    wasm_module_inst_t module_inst = get_module_inst(exec_env);
+    wasi_ctx_t wasi_ctx = get_wasi_ctx(module_inst);
+    struct fd_table *curfds = NULL;
+
+    if (!wasi_ctx)
+        return __WASI_EACCES;
+
+    curfds = wasi_ctx_get_curfds(module_inst, wasi_ctx);
+
+    return wasi_ssp_sock_get_reuse_port(curfds, fd, reuse);
 }
 
 static wasi_errno_t
 wasi_sock_get_send_buf_size(wasm_exec_env_t exec_env, wasi_fd_t fd,
                             wasi_size_t *size)
 {
-    return __WASI_ENOSYS;
+    wasm_module_inst_t module_inst = get_module_inst(exec_env);
+    wasi_ctx_t wasi_ctx = get_wasi_ctx(module_inst);
+    struct fd_table *curfds = NULL;
+
+    if (!wasi_ctx)
+        return __WASI_EACCES;
+
+    curfds = wasi_ctx_get_curfds(module_inst, wasi_ctx);
+
+    return wasi_ssp_sock_get_send_buf_size(curfds, fd, size);
 }
 
 static wasi_errno_t
@@ -1149,26 +1194,62 @@ static wasi_errno_t
 wasi_sock_set_recv_buf_size(wasm_exec_env_t exec_env, wasi_fd_t fd,
                             wasi_size_t size)
 {
-    return __WASI_ENOSYS;
+    wasm_module_inst_t module_inst = get_module_inst(exec_env);
+    wasi_ctx_t wasi_ctx = get_wasi_ctx(module_inst);
+    struct fd_table *curfds = NULL;
+
+    if (!wasi_ctx)
+        return __WASI_EACCES;
+
+    curfds = wasi_ctx_get_curfds(module_inst, wasi_ctx);
+
+    return wasi_ssp_sock_set_recv_buf_size(curfds, fd, size);
 }
 
 static wasi_errno_t
 wasi_sock_set_reuse_addr(wasm_exec_env_t exec_env, wasi_fd_t fd, uint8 reuse)
 {
-    return __WASI_ENOSYS;
+    wasm_module_inst_t module_inst = get_module_inst(exec_env);
+    wasi_ctx_t wasi_ctx = get_wasi_ctx(module_inst);
+    struct fd_table *curfds = NULL;
+
+    if (!wasi_ctx)
+        return __WASI_EACCES;
+
+    curfds = wasi_ctx_get_curfds(module_inst, wasi_ctx);
+
+    return wasi_ssp_sock_set_reuse_addr(curfds, fd, reuse);
 }
 
 static wasi_errno_t
 wasi_sock_set_reuse_port(wasm_exec_env_t exec_env, wasi_fd_t fd, uint8 reuse)
 {
-    return __WASI_ENOSYS;
+    wasm_module_inst_t module_inst = get_module_inst(exec_env);
+    wasi_ctx_t wasi_ctx = get_wasi_ctx(module_inst);
+    struct fd_table *curfds = NULL;
+
+    if (!wasi_ctx)
+        return __WASI_EACCES;
+
+    curfds = wasi_ctx_get_curfds(module_inst, wasi_ctx);
+
+    return wasi_ssp_sock_set_reuse_port(curfds, fd, reuse);
 }
 
 static wasi_errno_t
 wasi_sock_set_send_buf_size(wasm_exec_env_t exec_env, wasi_fd_t fd,
                             wasi_size_t size)
 {
-    return __WASI_ENOSYS;
+    wasm_module_inst_t module_inst = get_module_inst(exec_env);
+    wasi_ctx_t wasi_ctx = get_wasi_ctx(module_inst);
+    struct fd_table *curfds = NULL;
+
+    if (!wasi_ctx)
+        return __WASI_EACCES;
+
+    curfds = wasi_ctx_get_curfds(module_inst, wasi_ctx);
+
+    return wasi_ssp_sock_set_send_buf_size(curfds, fd, size);
 }
 
 static wasi_errno_t
@@ -1387,7 +1468,7 @@ static NativeSymbol native_symbols_libc_wasi[] = {
     REG_NATIVE_FUNC(proc_exit, "(i)"),
     REG_NATIVE_FUNC(proc_raise, "(i)i"),
     REG_NATIVE_FUNC(random_get, "(*~)i"),
-    REG_NATIVE_FUNC(sock_accept, "(i*)i"),
+    REG_NATIVE_FUNC(sock_accept, "(ii*)i"),
     REG_NATIVE_FUNC(sock_addr_local, "(i*i)i"),
     REG_NATIVE_FUNC(sock_addr_remote, "(i*i)i"),
     REG_NATIVE_FUNC(sock_addr_resolve, "(i*i*i)i"),
diff --git a/core/iwasm/libraries/libc-wasi/sandboxed-system-primitives/include/wasmtime_ssp.h b/core/iwasm/libraries/libc-wasi/sandboxed-system-primitives/include/wasmtime_ssp.h
index 8c9d265..bc63878 100644
--- a/core/iwasm/libraries/libc-wasi/sandboxed-system-primitives/include/wasmtime_ssp.h
+++ b/core/iwasm/libraries/libc-wasi/sandboxed-system-primitives/include/wasmtime_ssp.h
@@ -1006,6 +1006,14 @@ wasi_ssp_sock_addr_remote(
     __wasi_fd_t fd, uint8_t *buf, __wasi_size_t buf_len
 ) __attribute__((__warn_unused_result__));
 
+__wasi_errno_t
+wasi_ssp_sock_addr_resolve(
+#if !defined(WASMTIME_SSP_STATIC_CURFDS)
+    struct fd_table *curfds,
+#endif
+    __wasi_fd_t fd, const char *host, uint16_t port, uint8_t *buf, __wasi_size_t buf_len
+) __attribute__((__warn_unused_result__));
+
 __wasi_errno_t
 wasi_ssp_sock_open(
 #if !defined(WASMTIME_SSP_STATIC_CURFDS)
@@ -1031,6 +1039,70 @@ wasi_ssp_sock_connect(
     __wasi_fd_t fd, __wasi_addr_t *addr
 ) __attribute__((__warn_unused_result__));
 
+__wasi_errno_t
+wasi_ssp_sock_get_recv_buf_size(
+#if !defined(WASMTIME_SSP_STATIC_CURFDS)
+    struct fd_table *curfds,
+#endif
+    __wasi_fd_t fd, __wasi_size_t *size
+) __attribute__((__warn_unused_result__));
+
+__wasi_errno_t
+wasi_ssp_sock_get_reuse_addr(
+#if !defined(WASMTIME_SSP_STATIC_CURFDS)
+    struct fd_table *curfds,
+#endif
+    __wasi_fd_t fd, uint8_t *reuse
+) __attribute__((__warn_unused_result__));
+
+__wasi_errno_t
+wasi_ssp_sock_get_reuse_port(
+#if !defined(WASMTIME_SSP_STATIC_CURFDS)
+    struct fd_table *curfds,
+#endif
+    __wasi_fd_t fd, uint8_t *reuse
+) __attribute__((__warn_unused_result__));
+
+__wasi_errno_t
+wasi_ssp_sock_get_send_buf_size(
+#if !defined(WASMTIME_SSP_STATIC_CURFDS)
+    struct fd_table *curfds,
+#endif
+    __wasi_fd_t fd, __wasi_size_t *size
+) __attribute__((__warn_unused_result__));
+
+__wasi_errno_t
+wasi_ssp_sock_set_recv_buf_size(
+#if !defined(WASMTIME_SSP_STATIC_CURFDS)
+    struct fd_table *curfds,
+#endif
+    __wasi_fd_t fd, __wasi_size_t size
+) __attribute__((__warn_unused_result__));
+
+__wasi_errno_t
+wasi_ssp_sock_set_reuse_addr(
+#if !defined(WASMTIME_SSP_STATIC_CURFDS)
+    struct fd_table *curfds,
+#endif
+    __wasi_fd_t fd, uint8_t reuse
+) __attribute__((__warn_unused_result__));
+
+__wasi_errno_t
+wasi_ssp_sock_set_reuse_port(
+#if !defined(WASMTIME_SSP_STATIC_CURFDS)
+    struct fd_table *curfds,
+#endif
+    __wasi_fd_t fd, uint8_t reuse
+) __attribute__((__warn_unused_result__));
+
+__wasi_errno_t
+wasi_ssp_sock_set_send_buf_size(
+#if !defined(WASMTIME_SSP_STATIC_CURFDS)
+    struct fd_table *curfds,
+#endif
+    __wasi_fd_t fd, __wasi_size_t size
+) __attribute__((__warn_unused_result__));
+
 __wasi_errno_t
 wasi_ssp_sock_listen(
 #if !defined(WASMTIME_SSP_STATIC_CURFDS)
diff --git a/core/iwasm/libraries/libc-wasi/sandboxed-system-primitives/src/posix.c b/core/iwasm/libraries/libc-wasi/sandboxed-system-primitives/src/posix.c
index 4f1a1c9..c03d832 100644
--- a/core/iwasm/libraries/libc-wasi/sandboxed-system-primitives/src/posix.c
+++ b/core/iwasm/libraries/libc-wasi/sandboxed-system-primitives/src/posix.c
@@ -2860,8 +2860,18 @@ wasi_ssp_sock_addr_local(
     if (error != __WASI_ESUCCESS)
         return error;
 
+    __wasi_addr_t wasi_addr = {
+        .kind = IPv4
+    };
+    int ret = os_socket_getsockname(fd_number(fo), &wasi_addr.addr.ip4.addr, &wasi_addr.addr.ip4.port);
     fd_object_release(fo);
-    return __WASI_ENOSYS;
+    if (BHT_OK != ret) {
+        return convert_errno(errno);
+    }
+
+    bh_memcpy_s(buf, buf_len, &wasi_addr, sizeof(wasi_addr));
+
+    return __WASI_ESUCCESS;
 }
 
 __wasi_errno_t
@@ -2877,8 +2887,46 @@ wasi_ssp_sock_addr_remote(
     if (error != __WASI_ESUCCESS)
         return error;
 
+    __wasi_addr_t wasi_addr = {
+        .kind = IPv4
+    };
+    int ret = os_socket_getpeername(fd_number(fo), &wasi_addr.addr.ip4.addr, &wasi_addr.addr.ip4.port);
+    fd_object_release(fo);
+    if (BHT_OK != ret) {
+        return convert_errno(errno);
+    }
+
+    bh_memcpy_s(buf, buf_len, &wasi_addr, sizeof(wasi_addr));
+
+    return __WASI_ESUCCESS;
+}
+
+__wasi_errno_t
+wasi_ssp_sock_addr_resolve(
+#if !defined(WASMTIME_SSP_STATIC_CURFDS)
+    struct fd_table *curfds,
+#endif
+    __wasi_fd_t fd, const char *host, uint16_t port, uint8 *buf, __wasi_size_t buf_len)
+{
+    struct fd_object *fo;
+    __wasi_errno_t error =
+        fd_object_get(curfds, &fo, fd, __WASI_RIGHT_SOCK_ADDR_REMOTE, 0);
+    if (error != __WASI_ESUCCESS)
+        return error;
+
+    __wasi_addr_t wasi_addr = {
+        .kind = IPv4,
+        .addr.ip4.port = port
+     };
+    int ret = os_socket_inet_network(host, &wasi_addr.addr.ip4);
     fd_object_release(fo);
-    return __WASI_ENOSYS;
+    if (BHT_OK != ret) {
+        return convert_errno(errno);
+    }
+
+    bh_memcpy_s(buf, buf_len, &wasi_addr, sizeof(wasi_addr));
+
+    return __WASI_ESUCCESS;
 }
 
 __wasi_errno_t
@@ -2948,6 +2996,119 @@ wasi_ssp_sock_connect(
     return __WASI_ESUCCESS;
 }
 
+__wasi_errno_t
+wasi_ssp_sock_get_recv_buf_size(
+#if !defined(WASMTIME_SSP_STATIC_CURFDS)
+    struct fd_table *curfds,
+#endif
+    __wasi_fd_t fd, __wasi_size_t *size)
+{
+    struct fd_object *fo;
+    int ret;
+    __wasi_errno_t error =
+        fd_object_get(curfds, &fo, fd, 0, 0);
+    if (error != __WASI_ESUCCESS)
+        return error;
+
+    int optval;
+    socklen_t optlen = sizeof(optval);
+
+    ret = getsockopt(fd_number(fo), SOL_SOCKET, SO_RCVBUF, &optval, &optlen);
+    fd_object_release(fo);
+    if (BHT_OK != ret) {
+        return convert_errno(errno);
+    }
+
+    *size = optval;
+
+    return __WASI_ESUCCESS;
+}
+
+__wasi_errno_t
+wasi_ssp_sock_get_reuse_addr(
+#if !defined(WASMTIME_SSP_STATIC_CURFDS)
+    struct fd_table *curfds,
+#endif
+    __wasi_fd_t fd, uint8_t *reuse)
+{
+
+    struct fd_object *fo;
+    int ret;
+    __wasi_errno_t error =
+        fd_object_get(curfds, &fo, fd, 0, 0);
+    if (error != __WASI_ESUCCESS)
+        return error;
+
+    int optval;
+    socklen_t optlen = sizeof(optval);
+
+    ret = getsockopt(fd_number(fo), SOL_SOCKET, SO_REUSEADDR, &optval, &optlen);
+    fd_object_release(fo);
+    if (BHT_OK != ret) {
+        return convert_errno(errno);
+    }
+
+    *reuse = optval;
+
+    return __WASI_ESUCCESS;
+}
+
+__wasi_errno_t
+wasi_ssp_sock_get_reuse_port(
+#if !defined(WASMTIME_SSP_STATIC_CURFDS)
+    struct fd_table *curfds,
+#endif
+    __wasi_fd_t fd, uint8_t *reuse)
+{
+    struct fd_object *fo;
+    int ret;
+    __wasi_errno_t error =
+        fd_object_get(curfds, &fo, fd, 0, 0);
+    if (error != __WASI_ESUCCESS)
+        return error;
+
+    int optval;
+    socklen_t optlen = sizeof(optval);
+
+    ret = getsockopt(fd_number(fo), SOL_SOCKET, SO_REUSEPORT, &optval, &optlen);
+    fd_object_release(fo);
+    if (BHT_OK != ret) {
+        return convert_errno(errno);
+    }
+
+    *reuse = optval;
+
+    return __WASI_ESUCCESS;
+}
+
+__wasi_errno_t
+wasi_ssp_sock_get_send_buf_size(
+#if !defined(WASMTIME_SSP_STATIC_CURFDS)
+    struct fd_table *curfds,
+#endif
+    __wasi_fd_t fd, __wasi_size_t *size)
+{
+    struct fd_object *fo;
+    int ret;
+    __wasi_errno_t error =
+        fd_object_get(curfds, &fo, fd, 0, 0);
+    if (error != __WASI_ESUCCESS)
+        return error;
+
+    int optval;
+    socklen_t optlen = sizeof(optval);
+
+    ret = getsockopt(fd_number(fo), SOL_SOCKET, SO_SNDBUF, &optval, &optlen);
+    fd_object_release(fo);
+    if (BHT_OK != ret) {
+        return convert_errno(errno);
+    }
+
+    *size = optval;
+
+    return __WASI_ESUCCESS;
+}
+
 __wasi_errno_t
 wasi_ssp_sock_listen(
 #if !defined(WASMTIME_SSP_STATIC_CURFDS)
@@ -3023,6 +3184,106 @@ wasi_ssp_sock_open(
     return __WASI_ESUCCESS;
 }
 
+__wasi_errno_t
+wasi_ssp_sock_set_recv_buf_size(
+#if !defined(WASMTIME_SSP_STATIC_CURFDS)
+    struct fd_table *curfds,
+#endif
+    __wasi_fd_t fd, __wasi_size_t size)
+{
+    struct fd_object *fo;
+    int ret;
+    __wasi_errno_t error =
+        fd_object_get(curfds, &fo, fd, 0, 0);
+    if (error != __WASI_ESUCCESS)
+        return error;
+
+    int optval = size;
+
+    ret = setsockopt(fd_number(fo), SOL_SOCKET, SO_RCVBUF, &optval, sizeof(optval));
+    fd_object_release(fo);
+    if (BHT_OK != ret) {
+        return convert_errno(errno);
+    }
+
+    return __WASI_ESUCCESS;
+}
+
+__wasi_errno_t
+wasi_ssp_sock_set_reuse_addr(
+#if !defined(WASMTIME_SSP_STATIC_CURFDS)
+    struct fd_table *curfds,
+#endif
+    __wasi_fd_t fd, uint8_t reuse)
+{
+    struct fd_object *fo;
+    int ret;
+    __wasi_errno_t error =
+        fd_object_get(curfds, &fo, fd, 0, 0);
+    if (error != __WASI_ESUCCESS)
+        return error;
+
+    int optval = reuse;
+
+    ret = setsockopt(fd_number(fo), SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval));
+    fd_object_release(fo);
+    if (BHT_OK != ret) {
+        return convert_errno(errno);
+    }
+
+    return __WASI_ESUCCESS;
+}
+
+__wasi_errno_t
+wasi_ssp_sock_set_reuse_port(
+#if !defined(WASMTIME_SSP_STATIC_CURFDS)
+    struct fd_table *curfds,
+#endif
+    __wasi_fd_t fd, uint8_t reuse)
+{
+    struct fd_object *fo;
+    int ret;
+    __wasi_errno_t error =
+        fd_object_get(curfds, &fo, fd, 0, 0);
+    if (error != __WASI_ESUCCESS)
+        return error;
+
+    int optval = reuse;
+
+    ret = setsockopt(fd_number(fo), SOL_SOCKET, SO_REUSEPORT, &optval, sizeof(optval));
+    fd_object_release(fo);
+    if (BHT_OK != ret) {
+        return convert_errno(errno);
+    }
+
+    return __WASI_ESUCCESS;
+}
+
+__wasi_errno_t
+wasi_ssp_sock_set_send_buf_size(
+#if !defined(WASMTIME_SSP_STATIC_CURFDS)
+    struct fd_table *curfds,
+#endif
+    __wasi_fd_t fd, __wasi_size_t size)
+{
+    struct fd_object *fo;
+    int ret;
+    __wasi_errno_t error =
+        fd_object_get(curfds, &fo, fd, 0, 0);
+    if (error != __WASI_ESUCCESS)
+        return error;
+
+    int optval = size;
+
+    ret = setsockopt(fd_number(fo), SOL_SOCKET, SO_SNDBUF, &optval, sizeof(optval));
+    fd_object_release(fo);
+    if (BHT_OK != ret) {
+        return convert_errno(errno);
+    }
+
+    return __WASI_ESUCCESS;
+}
+
 __wasi_errno_t
 wasmtime_ssp_sock_recv(
 #if !defined(WASMTIME_SSP_STATIC_CURFDS)
diff --git a/core/iwasm/libraries/libc-wasi/sandboxed-system-primitives/src/ssp_config.h b/core/iwasm/libraries/libc-wasi/sandboxed-system-primitives/src/ssp_config.h
index 47b65ca..347569b 100644
--- a/core/iwasm/libraries/libc-wasi/sandboxed-system-primitives/src/ssp_config.h
+++ b/core/iwasm/libraries/libc-wasi/sandboxed-system-primitives/src/ssp_config.h
@@ -25,7 +25,7 @@
 
 // On Linux, prefer to use getrandom, though it isn't available in
 // GLIBC before 2.25.
-#if defined(__linux__)                       \
+#if defined(__linux__) || defined(ESP_PLATFORM) \
     && (!defined(__GLIBC__) || __GLIBC__ > 2 \
         || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 25))
 #define CONFIG_HAS_GETRANDOM 1
@@ -39,13 +39,13 @@
 #define CONFIG_HAS_CAP_ENTER 0
 #endif
 
-#if !defined(__APPLE__) && !defined(__FreeBSD__) && !defined(__EMSCRIPTEN__)
+#if !defined(__APPLE__) && !defined(__FreeBSD__) && !defined(__EMSCRIPTEN__) && !defined(ESP_PLATFORM)
 #define CONFIG_HAS_CLOCK_NANOSLEEP 1
 #else
 #define CONFIG_HAS_CLOCK_NANOSLEEP 0
 #endif
 
-#if !defined(__APPLE__) && !defined(__FreeBSD__)
+#if !defined(__APPLE__) && !defined(__FreeBSD__) && !defined(ESP_PLATFORM)
 #define CONFIG_HAS_FDATASYNC 1
 #else
 #define CONFIG_HAS_FDATASYNC 0
@@ -63,13 +63,13 @@
 #endif
 #endif
 
-#ifndef __APPLE__
+#if !defined(__APPLE__) && !defined(ESP_PLATFORM)
 #define CONFIG_HAS_POSIX_FALLOCATE 1
 #else
 #define CONFIG_HAS_POSIX_FALLOCATE 0
 #endif
 
-#ifndef __APPLE__
+#if !defined(__APPLE__) && !defined(ESP_PLATFORM)
 #define CONFIG_HAS_PREADV 1
 #else
 #define CONFIG_HAS_PREADV 0
@@ -87,7 +87,7 @@
 #define CONFIG_HAS_PTHREAD_CONDATTR_SETCLOCK 0
 #endif
 
-#ifndef __APPLE__
+#if !defined(__APPLE__) && !defined(ESP_PLATFORM)
 #define CONFIG_HAS_PWRITEV 1
 #else
 #define CONFIG_HAS_PWRITEV 0
diff --git a/core/shared/platform/esp-idf/espidf_memmap.c b/core/shared/platform/esp-idf/espidf_memmap.c
index 693094a..709a8e8 100644
--- a/core/shared/platform/esp-idf/espidf_memmap.c
+++ b/core/shared/platform/esp-idf/espidf_memmap.c
@@ -9,6 +9,9 @@
 void *
 os_mmap(void *hint, size_t size, int prot, int flags)
 {
+#ifdef CONFIG_SPIRAM
+    return heap_caps_aligned_alloc(8, size, MALLOC_CAP_SPIRAM);
+#else
     if (prot & MMAP_PROT_EXEC) {
         // Memory allocation with MALLOC_CAP_EXEC will return 4-byte aligned
         // Reserve extra 4 byte to fixup alignment and size for the pointer to
@@ -30,6 +33,7 @@ os_mmap(void *hint, size_t size, int prot, int flags)
     else {
         return os_malloc(size);
     }
+#endif
 }
 
 void
@@ -37,7 +41,11 @@ os_munmap(void *addr, size_t size)
 {
     // We don't need special handling of the executable allocations
     // here, free() of esp-idf handles it properly
+#ifdef CONFIG_SPIRAM
+    heap_caps_free(addr);
+#else
     return os_free(addr);
+#endif
 }
 
 int
@@ -47,5 +55,16 @@ os_mprotect(void *addr, size_t size, int prot)
 }
 
 void
-os_dcache_flush()
-{}
+IRAM_ATTR os_dcache_flush()
+{
+#ifdef CONFIG_SPIRAM
+    extern void Cache_WriteBack_All(void);
+    extern void spi_flash_disable_interrupts_caches_and_other_cpu(void);
+    extern void spi_flash_enable_interrupts_caches_and_other_cpu(void);
+
+    Cache_WriteBack_All();
+
+    spi_flash_disable_interrupts_caches_and_other_cpu();
+    spi_flash_enable_interrupts_caches_and_other_cpu();
+#endif
+}
diff --git a/core/shared/platform/esp-idf/espidf_platform.c b/core/shared/platform/esp-idf/espidf_platform.c
index af6be88..905217b 100644
--- a/core/shared/platform/esp-idf/espidf_platform.c
+++ b/core/shared/platform/esp-idf/espidf_platform.c
@@ -5,6 +5,7 @@
 
 #include "platform_api_vmcore.h"
 #include "platform_api_extension.h"
+#include "esp_idf_version.h"
 
 int
 bh_platform_init()
@@ -58,3 +59,197 @@ os_usleep(uint32 usec)
 {
     return usleep(usec);
 }
+
+/* Below parts of readv & writev are ported from Nuttx, under Apache License v2.0 */
+
+ssize_t
+readv(int fildes, const struct iovec *iov, int iovcnt)
+{
+  ssize_t ntotal;
+  ssize_t nread;
+  size_t remaining;
+  uint8_t *buffer;
+  int i;
+
+  /* Process each entry in the struct iovec array */
+
+  for (i = 0, ntotal = 0; i < iovcnt; i++)
+    {
+      /* Ignore zero-length reads */
+
+      if (iov[i].iov_len > 0)
+        {
+          buffer    = iov[i].iov_base;
+          remaining = iov[i].iov_len;
+
+          /* Read repeatedly as necessary to fill buffer */
+
+          do
+            {
+              /* NOTE:  read() is a cancellation point */
+
+              nread = read(fildes, buffer, remaining);
+
+              /* Check for a read error */
+
+              if (nread < 0)
+                {
+                  return nread;
+                }
+
+              /* Check for an end-of-file condition */
+
+              else if (nread == 0)
+                {
+                  return ntotal;
+                }
+
+              /* Update pointers and counts in order to handle partial
+               * buffer reads.
+               */
+
+              buffer    += nread;
+              remaining -= nread;
+              ntotal    += nread;
+            }
+          while (remaining > 0);
+        }
+    }
+
+  return ntotal;
+}
+
+ssize_t
+writev(int fildes, const struct iovec *iov, int iovcnt)
+{
+  ssize_t ntotal;
+  ssize_t nwritten;
+  size_t remaining;
+  uint8_t *buffer;
+  int i;
+
+  /* Process each entry in the struct iovec array */
+
+  for (i = 0, ntotal = 0; i < iovcnt; i++)
+    {
+      /* Ignore zero-length writes */
+
+      if (iov[i].iov_len > 0)
+        {
+          buffer    = iov[i].iov_base;
+          remaining = iov[i].iov_len;
+
+          /* Write repeatedly as necessary to write the entire buffer */
+
+          do
+            {
+              /* NOTE:  write() is a cancellation point */
+
+              nwritten = write(fildes, buffer, remaining);
+
+              /* Check for a write error */
+
+              if (nwritten < 0)
+                {
+                  return ntotal ? ntotal : -1;
+                }
+
+              /* Update pointers and counts in order to handle partial
+               * buffer writes.
+               */
+
+              buffer    += nwritten;
+              remaining -= nwritten;
+              ntotal    += nwritten;
+            }
+          while (remaining > 0);
+        }
+    }
+
+  return ntotal;
+}
+
+int
+fstatat(int fd, const char *path, struct stat *buf, int flag)
+{
+    errno = ENOSYS;
+    return -1;
+}
+
+int
+mkdirat(int fd, const char *path, mode_t mode)
+{
+    errno = ENOSYS;
+    return -1;
+}
+
+ssize_t
+readlinkat(int fd, const char *path, char *buf, size_t bufsize)
+{
+    errno = EINVAL;
+    return -1;
+}
+
+int
+linkat(int fd1, const char *path1, int fd2, const char *path2, int flag)
+{
+    errno = ENOSYS;
+    return -1;
+}
+
+int
+renameat(int fromfd, const char *from, int tofd, const char *to)
+{
+    errno = ENOSYS;
+    return -1;
+}
+
+int
+symlinkat(const char *target, int fd, const char *path)
+{
+    errno = ENOSYS;
+    return -1;
+}
+
+int
+unlinkat(int fd, const char *path, int flag)
+{
+    errno = ENOSYS;
+    return -1;
+}
+
+int
+#if ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(5, 2, 0)
+utimensat(int fd, const char *path, const struct timespec ts[2], int flag)
+#else
+utimensat(int fd, const char *path, const struct timespec *ts, int flag)
+#endif
+{
+    errno = ENOSYS;
+    return -1;
+}
+
+DIR *
+fdopendir(int fd)
+{
+    errno = ENOSYS;
+    return NULL;
+}
+
+int
+#if ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(5, 2, 0)
+futimens(int fd, const struct timespec times[2])
+#else
+futimens(int fd, const struct timespec *times)
+#endif
+{
+    errno = ENOSYS;
+    return -1;
+}
+
+int
+nanosleep(const struct timespec *req, struct timespec *rem)
+{
+    errno = ENOSYS;
+    return -1;
+}
\ No newline at end of file
diff --git a/core/shared/platform/esp-idf/espidf_socket.c b/core/shared/platform/esp-idf/espidf_socket.c
new file mode 100644
index 0000000..0f18095
--- /dev/null
+++ b/core/shared/platform/esp-idf/espidf_socket.c
@@ -0,0 +1,196 @@
+/*
+ * Copyright (C) 2021 Intel Corporation.  All rights reserved.
+ * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+ */
+
+#include "platform_api_vmcore.h"
+#include "platform_api_extension.h"
+
+#include <arpa/inet.h>
+
+static void
+textual_addr_to_sockaddr(const char *textual, int port, struct sockaddr_in *out)
+{
+    assert(textual);
+
+    out->sin_family = AF_INET;
+    out->sin_port = htons(port);
+    out->sin_addr.s_addr = inet_addr(textual);
+}
+
+int
+os_socket_create(bh_socket_t *sock, int tcp_or_udp)
+{
+    if (!sock) {
+        return BHT_ERROR;
+    }
+
+    if (1 == tcp_or_udp) {
+        *sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
+    }
+    else if (0 == tcp_or_udp) {
+        *sock = socket(AF_INET, SOCK_DGRAM, 0);
+    }
+
+    return (*sock == -1) ? BHT_ERROR : BHT_OK;
+}
+
+int
+os_socket_bind(bh_socket_t socket, const char *host, int *port)
+{
+    struct sockaddr_in addr;
+    socklen_t socklen;
+    int ret;
+
+    assert(host);
+    assert(port);
+
+    addr.sin_addr.s_addr = inet_addr(host);
+    addr.sin_port = htons(*port);
+    addr.sin_family = AF_INET;
+
+    ret = bind(socket, (struct sockaddr *)&addr, sizeof(addr));
+    if (ret < 0) {
+        goto fail;
+    }
+
+    socklen = sizeof(addr);
+    if (getsockname(socket, (void *)&addr, &socklen) == -1) {
+        goto fail;
+    }
+
+    *port = ntohs(addr.sin_port);
+
+    return BHT_OK;
+
+fail:
+    return BHT_ERROR;
+}
+
+int
+os_socket_settimeout(bh_socket_t socket, uint64 timeout_us)
+{
+    struct timeval tv;
+    tv.tv_sec = timeout_us / 1000000UL;
+    tv.tv_usec = timeout_us % 1000000UL;
+
+    if (setsockopt(socket, SOL_SOCKET, SO_RCVTIMEO, (const char *)&tv,
+                   sizeof(tv))
+        != 0) {
+        return BHT_ERROR;
+    }
+
+    return BHT_OK;
+}
+
+int
+os_socket_listen(bh_socket_t socket, int max_client)
+{
+    if (listen(socket, max_client) != 0) {
+        return BHT_ERROR;
+    }
+
+    return BHT_OK;
+}
+
+int
+os_socket_accept(bh_socket_t server_sock, bh_socket_t *sock, void *addr,
+                 unsigned int *addrlen)
+{
+    struct sockaddr addr_tmp;
+    unsigned int len = sizeof(struct sockaddr);
+
+    *sock = accept(server_sock, (struct sockaddr *)&addr_tmp, &len);
+
+    if (*sock < 0) {
+        return BHT_ERROR;
+    }
+
+    return BHT_OK;
+}
+
+int
+os_socket_connect(bh_socket_t socket, const char *addr, int port)
+{
+    struct sockaddr_in addr_in = { 0 };
+    socklen_t addr_len = sizeof(struct sockaddr_in);
+    int ret = 0;
+
+    textual_addr_to_sockaddr(addr, port, &addr_in);
+
+    ret = connect(socket, (struct sockaddr *)&addr_in, addr_len);
+    if (ret == -1) {
+        return BHT_ERROR;
+    }
+
+    return BHT_OK;
+}
+
+int
+os_socket_recv(bh_socket_t socket, void *buf, unsigned int len)
+{
+    return recv(socket, buf, len, 0);
+}
+
+int
+os_socket_send(bh_socket_t socket, const void *buf, unsigned int len)
+{
+    return send(socket, buf, len, 0);
+}
+
+int
+os_socket_close(bh_socket_t socket)
+{
+    close(socket);
+    return BHT_OK;
+}
+
+int
+os_socket_shutdown(bh_socket_t socket)
+{
+    shutdown(socket, O_RDWR);
+    return BHT_OK;
+}
+
+int
+os_socket_inet_network(const char *cp, uint32 *out)
+{
+    if (!cp)
+        return BHT_ERROR;
+
+    /* Note: ntohl(INADDR_NONE) == INADDR_NONE */
+    *out = ntohl(inet_addr(cp));
+    return BHT_OK;
+}
+
+int
+os_socket_getpeername(bh_socket_t socket, uint32 *addr, int *port)
+{
+    struct sockaddr_in address;
+    socklen_t addr_len = sizeof(struct sockaddr_in);
+
+    if (getpeername(socket, &address, &addr_len) == -1) {
+        return BHT_ERROR;
+    }
+
+    *addr = address.sin_addr.s_addr;
+    *port = address.sin_port;
+
+    return BHT_OK;
+}
+
+int
+os_socket_getsockname(bh_socket_t socket, uint32 *addr, int *port)
+{
+    struct sockaddr_in address;
+    socklen_t addr_len = sizeof(struct sockaddr_in);
+
+    if (getsockname(socket, &address, &addr_len) == -1) {
+        return BHT_ERROR;
+    }
+
+    *addr = address.sin_addr.s_addr;
+    *port = address.sin_port;
+
+    return BHT_OK;
+}
diff --git a/core/shared/platform/esp-idf/espidf_thread.c b/core/shared/platform/esp-idf/espidf_thread.c
index c8d7a82..637cd41 100644
--- a/core/shared/platform/esp-idf/espidf_thread.c
+++ b/core/shared/platform/esp-idf/espidf_thread.c
@@ -44,6 +44,25 @@ os_mutex_init(korp_mutex *mutex)
     return pthread_mutex_init(mutex, NULL);
 }
 
+int
+os_recursive_mutex_init(korp_mutex *mutex)
+{
+    int ret;
+
+    pthread_mutexattr_t mattr;
+
+    assert(mutex);
+    ret = pthread_mutexattr_init(&mattr);
+    if (ret)
+        return BHT_ERROR;
+
+    pthread_mutexattr_settype(&mattr, PTHREAD_MUTEX_RECURSIVE);
+    ret = pthread_mutex_init(mutex, &mattr);
+    pthread_mutexattr_destroy(&mattr);
+
+    return ret == 0 ? BHT_OK : BHT_ERROR;
+}
+
 int
 os_mutex_destroy(korp_mutex *mutex)
 {
@@ -206,3 +225,9 @@ os_cond_signal(korp_cond *cond)
 {
     return pthread_cond_signal(cond);
 }
+
+int
+os_cond_broadcast(korp_cond *cond)
+{
+    return pthread_cond_broadcast(cond);
+}
\ No newline at end of file
diff --git a/core/shared/platform/esp-idf/platform_internal.h b/core/shared/platform/esp-idf/platform_internal.h
index fabc43f..610c7c2 100644
--- a/core/shared/platform/esp-idf/platform_internal.h
+++ b/core/shared/platform/esp-idf/platform_internal.h
@@ -17,6 +17,10 @@
 #include <math.h>
 #include <unistd.h>
 #include <pthread.h>
+#include <arpa/inet.h>
+#include <sys/socket.h>
+#include <sys/uio.h>
+#include <dirent.h>
 
 #include "esp_pthread.h"
 #include "esp_timer.h"
@@ -41,6 +45,65 @@ typedef pthread_t korp_thread;
 /* Default thread priority */
 #define BH_THREAD_DEFAULT_PRIORITY 5
 
+/* Special value for tv_nsec field of timespec */
+
+#define UTIME_NOW     ((1l << 30) - 1l)
+#ifndef __cplusplus
+#  define UTIME_OMIT  ((1l << 30) - 2l)
+#endif
+
+#ifdef DT_UNKNOWN
+#undef DT_UNKNOWN
+#endif
+
+#ifdef DT_REG
+#undef DT_REG
+#endif
+
+#ifdef DT_DIR
+#undef DT_DIR
+#endif
+
+/* Below parts of d_type define are ported from Nuttx, under Apache License v2.0 */
+
+/* File type code for the d_type field in dirent structure.
+ * Note that because of the simplified filesystem organization of the NuttX,
+ * top-level, pseudo-file system, an inode can be BOTH a file and a directory
+ */
+
+#define DTYPE_UNKNOWN             0
+#define DTYPE_FIFO                1
+#define DTYPE_CHR                 2
+#define DTYPE_SEM                 3
+#define DTYPE_DIRECTORY           4
+#define DTYPE_MQ                  5
+#define DTYPE_BLK                 6
+#define DTYPE_SHM                 7
+#define DTYPE_FILE                8
+#define DTYPE_MTD                 9
+#define DTYPE_LINK                10
+#define DTYPE_SOCK                12
+
+/* The d_type field of the dirent structure is not specified by POSIX.  It
+ * is a non-standard, 4.5BSD extension that is implemented by most OSs.  A
+ * POSIX compliant OS may not implement the d_type field at all.  Many OS's
+ * (including glibc) may use the following alternative naming for the file
+ * type names:
+ */
+
+#define DT_UNKNOWN                DTYPE_UNKNOWN
+#define DT_FIFO                   DTYPE_FIFO
+#define DT_CHR                    DTYPE_CHR
+#define DT_SEM                    DTYPE_SEM
+#define DT_DIR                    DTYPE_DIRECTORY
+#define DT_MQ                     DTYPE_MQ
+#define DT_BLK                    DTYPE_BLK
+#define DT_SHM                    DTYPE_SHM
+#define DT_REG                    DTYPE_FILE
+#define DT_MTD                    DTYPE_MTD
+#define DT_LNK                    DTYPE_LINK
+#define DT_SOCK                   DTYPE_SOCK
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/core/shared/platform/include/platform_api_extension.h b/core/shared/platform/include/platform_api_extension.h
index c13b68f..4e156d0 100644
--- a/core/shared/platform/include/platform_api_extension.h
+++ b/core/shared/platform/include/platform_api_extension.h
@@ -339,6 +339,36 @@ os_socket_shutdown(bh_socket_t socket);
 int
 os_socket_inet_network(const char *cp, uint32 *out);
 
+/**
+ * Get the peer address of the connected to the socket
+ *
+ * @param socket  [INTPUT] the connected socket
+ * @param addr    [OUTPUT] the address of the peer socket. If addr is NULL,
+ *                nothing is filled in, and addrlen will not be used
+ * @param port    [OUTPUT] the port number, if the value is 0,
+ *                it will use a port assigned by OS. On return it will
+ *                contain the actual bound port number
+ *
+ * @return 0 if success, -1 otherwise
+ */
+int
+os_socket_getpeername(bh_socket_t socket, uint32 *addr, int *port);
+
+/**
+ * Get the current address of the bound to the socket
+ *
+ * @param socket  [INTPUT] the bound socket
+ * @param addr    [OUTPUT] the address of the bound socket. If addr is NULL,
+ *                nothing is filled in, and addrlen will not be used
+ * @param port    [OUTPUT] the port number, if the value is 0,
+ *                it will use a port assigned by OS. On return it will
+ *                contain the actual bound port number
+ *
+ * @return 0 if success, -1 otherwise
+ */
+int
+os_socket_getsockname(bh_socket_t socket, uint32 *addr, int *port);
+
 #ifdef __cplusplus
 }
 #endif
